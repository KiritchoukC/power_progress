// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'week_enum.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$WeekEnumTearOff {
  const _$WeekEnumTearOff();

  Accumulation accumulation() {
    return const Accumulation();
  }

  Intensification intensification() {
    return const Intensification();
  }

  Realization realization() {
    return const Realization();
  }

  Deload deload() {
    return const Deload();
  }
}

// ignore: unused_element
const $WeekEnum = _$WeekEnumTearOff();

mixin _$WeekEnum {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result accumulation(),
    @required Result intensification(),
    @required Result realization(),
    @required Result deload(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result accumulation(),
    Result intensification(),
    Result realization(),
    Result deload(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result accumulation(Accumulation value),
    @required Result intensification(Intensification value),
    @required Result realization(Realization value),
    @required Result deload(Deload value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result accumulation(Accumulation value),
    Result intensification(Intensification value),
    Result realization(Realization value),
    Result deload(Deload value),
    @required Result orElse(),
  });
}

abstract class $WeekEnumCopyWith<$Res> {
  factory $WeekEnumCopyWith(WeekEnum value, $Res Function(WeekEnum) then) =
      _$WeekEnumCopyWithImpl<$Res>;
}

class _$WeekEnumCopyWithImpl<$Res> implements $WeekEnumCopyWith<$Res> {
  _$WeekEnumCopyWithImpl(this._value, this._then);

  final WeekEnum _value;
  // ignore: unused_field
  final $Res Function(WeekEnum) _then;
}

abstract class $AccumulationCopyWith<$Res> {
  factory $AccumulationCopyWith(
          Accumulation value, $Res Function(Accumulation) then) =
      _$AccumulationCopyWithImpl<$Res>;
}

class _$AccumulationCopyWithImpl<$Res> extends _$WeekEnumCopyWithImpl<$Res>
    implements $AccumulationCopyWith<$Res> {
  _$AccumulationCopyWithImpl(
      Accumulation _value, $Res Function(Accumulation) _then)
      : super(_value, (v) => _then(v as Accumulation));

  @override
  Accumulation get _value => super._value as Accumulation;
}

class _$Accumulation implements Accumulation {
  const _$Accumulation();

  @override
  String toString() {
    return 'WeekEnum.accumulation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Accumulation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result accumulation(),
    @required Result intensification(),
    @required Result realization(),
    @required Result deload(),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return accumulation();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result accumulation(),
    Result intensification(),
    Result realization(),
    Result deload(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accumulation != null) {
      return accumulation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result accumulation(Accumulation value),
    @required Result intensification(Intensification value),
    @required Result realization(Realization value),
    @required Result deload(Deload value),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return accumulation(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result accumulation(Accumulation value),
    Result intensification(Intensification value),
    Result realization(Realization value),
    Result deload(Deload value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accumulation != null) {
      return accumulation(this);
    }
    return orElse();
  }
}

abstract class Accumulation implements WeekEnum {
  const factory Accumulation() = _$Accumulation;
}

abstract class $IntensificationCopyWith<$Res> {
  factory $IntensificationCopyWith(
          Intensification value, $Res Function(Intensification) then) =
      _$IntensificationCopyWithImpl<$Res>;
}

class _$IntensificationCopyWithImpl<$Res> extends _$WeekEnumCopyWithImpl<$Res>
    implements $IntensificationCopyWith<$Res> {
  _$IntensificationCopyWithImpl(
      Intensification _value, $Res Function(Intensification) _then)
      : super(_value, (v) => _then(v as Intensification));

  @override
  Intensification get _value => super._value as Intensification;
}

class _$Intensification implements Intensification {
  const _$Intensification();

  @override
  String toString() {
    return 'WeekEnum.intensification()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Intensification);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result accumulation(),
    @required Result intensification(),
    @required Result realization(),
    @required Result deload(),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return intensification();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result accumulation(),
    Result intensification(),
    Result realization(),
    Result deload(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (intensification != null) {
      return intensification();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result accumulation(Accumulation value),
    @required Result intensification(Intensification value),
    @required Result realization(Realization value),
    @required Result deload(Deload value),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return intensification(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result accumulation(Accumulation value),
    Result intensification(Intensification value),
    Result realization(Realization value),
    Result deload(Deload value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (intensification != null) {
      return intensification(this);
    }
    return orElse();
  }
}

abstract class Intensification implements WeekEnum {
  const factory Intensification() = _$Intensification;
}

abstract class $RealizationCopyWith<$Res> {
  factory $RealizationCopyWith(
          Realization value, $Res Function(Realization) then) =
      _$RealizationCopyWithImpl<$Res>;
}

class _$RealizationCopyWithImpl<$Res> extends _$WeekEnumCopyWithImpl<$Res>
    implements $RealizationCopyWith<$Res> {
  _$RealizationCopyWithImpl(
      Realization _value, $Res Function(Realization) _then)
      : super(_value, (v) => _then(v as Realization));

  @override
  Realization get _value => super._value as Realization;
}

class _$Realization implements Realization {
  const _$Realization();

  @override
  String toString() {
    return 'WeekEnum.realization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Realization);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result accumulation(),
    @required Result intensification(),
    @required Result realization(),
    @required Result deload(),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return realization();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result accumulation(),
    Result intensification(),
    Result realization(),
    Result deload(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (realization != null) {
      return realization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result accumulation(Accumulation value),
    @required Result intensification(Intensification value),
    @required Result realization(Realization value),
    @required Result deload(Deload value),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return realization(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result accumulation(Accumulation value),
    Result intensification(Intensification value),
    Result realization(Realization value),
    Result deload(Deload value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (realization != null) {
      return realization(this);
    }
    return orElse();
  }
}

abstract class Realization implements WeekEnum {
  const factory Realization() = _$Realization;
}

abstract class $DeloadCopyWith<$Res> {
  factory $DeloadCopyWith(Deload value, $Res Function(Deload) then) =
      _$DeloadCopyWithImpl<$Res>;
}

class _$DeloadCopyWithImpl<$Res> extends _$WeekEnumCopyWithImpl<$Res>
    implements $DeloadCopyWith<$Res> {
  _$DeloadCopyWithImpl(Deload _value, $Res Function(Deload) _then)
      : super(_value, (v) => _then(v as Deload));

  @override
  Deload get _value => super._value as Deload;
}

class _$Deload implements Deload {
  const _$Deload();

  @override
  String toString() {
    return 'WeekEnum.deload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Deload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result accumulation(),
    @required Result intensification(),
    @required Result realization(),
    @required Result deload(),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return deload();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result accumulation(),
    Result intensification(),
    Result realization(),
    Result deload(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deload != null) {
      return deload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result accumulation(Accumulation value),
    @required Result intensification(Intensification value),
    @required Result realization(Realization value),
    @required Result deload(Deload value),
  }) {
    assert(accumulation != null);
    assert(intensification != null);
    assert(realization != null);
    assert(deload != null);
    return deload(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result accumulation(Accumulation value),
    Result intensification(Intensification value),
    Result realization(Realization value),
    Result deload(Deload value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deload != null) {
      return deload(this);
    }
    return orElse();
  }
}

abstract class Deload implements WeekEnum {
  const factory Deload() = _$Deload;
}
